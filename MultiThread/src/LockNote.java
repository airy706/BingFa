public class LockNote {
    /*
    Lock接口（并发包）：与synchronized（隐式解锁）对比，具有加锁和解锁的可操作性、非阻塞获取锁（调用完方法后
    立即返回，true或者false）、可中断获取锁、超时获取锁
    队列同步器：violate类型的int型变量state表示同步状态
        方法：getstate()，setstate(),casstate()
        模板方法：acquire(独占式，会阻塞，不会响应中断)，acquireInteruptly(),acquireNanos(超时)，release()
                acquireShared(共享式)
        重写方法：tryacquire(独占式获同步状态，进行CAS更新)，tryRealse(),tryacquireSHared(共享式获取同步状态，返回值大于0代表获取成功)，isExclude（是否独占）
    同步对列：同步器中包含头节点尾结点引用，获取同步状态失败的线程会构造成节点进入同步对列尾部，头节点为成功获取
            同步状态的线程，头节点释放锁后，后继节点才可以继续获取锁
    独占式获取同步状态：tryacquire失败，构造节点进入同步对列尾部，节点进行自旋，判断当前节点的前驱节点是否为头节点，若为头节点且成功获取同步状态
                      则退出自旋，获取成功
         独占式释放：调用tryrelease()释放同步状态，使用lockSUPPORT唤醒后继节点
         独占式超时获取：节点进入自旋，判断是否超时，超时退出
    共享式：tryreleaseShared()失败，同上，try返回值大于0代表获取成功



    重入锁：支持重进入的锁，获取锁的线程可以再次获取锁。
        锁的再次获取：线程尝试获取锁时，锁判断获取锁的线程是是否为当前占有锁的线程，是则成功获取，同步状态增加
        锁的最终释放：线程成功获取锁，同步状态自增，释放锁，同步状态自减，当同步状态为0时，成功释放锁

        公平锁：锁的获取顺序与请求的绝对时间顺序一致
        在尝试获取锁的过程中判断当前线程节点是否有前驱节点，有的化则等待前去线程获取锁并释放锁之后才可以获取锁

     读写锁：维护一对锁，读锁和写锁，可以在同一时间内被多个线程访问，当写锁被访问时，其他的读写操作被阻塞，直到写锁被释放。
        读写状态：读（高16位），写（低16位）
        读锁时支持冲进入的共享锁，当写锁没有被其他线程获取时，读锁总是可以成功获取，写锁被其他线程获取时，读锁的获取被阻塞（保证内存可见性）
        写锁是支持重进入的排它锁，当读锁被获取时（读写锁保证写锁对读锁的可见性）或该线程不是当前占有写锁的线程，获取写锁阻塞。
        锁降级：写锁降级为读锁，把持住已经获取的写锁，再获取读锁，释放写锁。对于多线程之间的数据处理，如果线程A获取写锁之后释放写锁，其他线程T获取写锁进行数据处理
               ，对线程A不可见的。



    condition接口：类似于对象的监视器（wait,notify）,与lock配合，实现等待通知模式。
    获取：获取与c关联的锁，在从锁中获取C,lock.lock();lock.newCondition();
    与监视器区别：可以不支持中断进入等待状态，可以有多个等待对列
    方法：await(),使调用该方法线程进入等待状态，释放锁；
         awailtNanos()，超时等待
         signal(),signalAll(),唤醒在C上等待的线程
    condition对象内包含着等待队列，c中包含头节点与尾结点的引用，同步器拥有一个同步对列和多个等待队列
    await()使当前线程释放锁，构造节点进入等待队列尾部 ，相当于同步对列中首节点（获取锁）释放锁，进去等待队列的尾部
   signal()方法会唤醒在等待对列中等待时间最长的线程节点（头节点），使其进去同步对列，然后使用lockSupport唤醒节点线程。



     */
}
