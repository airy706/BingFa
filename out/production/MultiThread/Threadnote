线程的优先级：继承性（继承父线程的优先级），规则性、随机性

线程的状态：new runnable blocked waiting time-waiting terminated(生命周期内6个状态)
    线程阻塞与synchronized()代码时，阻塞状态
    阻塞于Lock接口代码时，等待状态

守护线程：用于程序的后天调度和支持性工作
可将线程设置为守护线程（线程执行之前），虚拟机不存在守护线程时，自动退出

启动和终止

线程对象的初始化：在父线程（当前线程）内构造线程对象，初始化包括优先级、是否为守护线程（继承于父线程）、可继承的ThreadLocal
,唯一的线程ID
初始化完成之后，线程对象存放在堆内存中等待运行
启动：
线程对象调用start()方法，当前线程（父线程）同步通知虚拟机，只要线程规划器空闲，可以启动调用start的线程。
终止：
    中断方式：
    退出标志：判断是否需要终止线程
    可以有机会释放线程占有的资源



线程通信：
    volatile和synchronized关键字：v用于修饰共享变量，保证多线程中共享变量的可见性，一个队V的读，总是能获取到
    主内存中其他线程队V的最后的写；队V的写，本地内存中共享变量刷新到主内存，读，本地内存置为无效，从主内存读
    单个读写操作具有原子性，CAS更新
    s用于修饰同步方法和代码块，保证同一时刻，只有一个线程处于同步代码（原子性）中。线程尝试进入同步方法或代码块时，会尝试获取
    当前对象（配置对象）的监视器，获取监视器即为获取到锁（当前实例对象、类Class对象），执行同步操作；获取失败时阻塞在入口，进入同步对列
    只有当已经获取到锁的线程释放锁时，才会唤醒同步对列的线程，尝试重新获取监视器。通过加锁解锁时对volatile变量state
    的读写保证变量的可见性，通过锁的互斥特性保证同一时刻只要一个线程处于同步代码中。

    等待/通知机制：线程A调用对象O的wait()方法进入等待状态，线程B调用对象O的notify()/notifyall()方法，
    线程A在获取通知后从对象O的wait()返回。
    wait()：调用wait（）方法的线程进入等待状态，等待其他线程的通知或中断才会返回，调用该方法后，线程会立即释放锁
    notify():通知一个在对象上等待的线程，使其从wait方法中返回，返回的前提是线程获取到对象的锁。

    细节：调用wait()和notify()时都需要获取对象的锁，wait使线程进入等待对列，变为等待状态，notify向在对象上等待
    的线程发送通知，时等待队列中的一个线程进入同步队列。当执行notify方法的线程执行完同步代码时释放锁，线程尝试获取锁，
    只有获取锁才能从wait中返回

    等待通知经典范式：
    等待方：
    获取对象锁、判断条件是否满足，不满足则调用wait(),满足则执行对应逻辑
    通知方：
    获取对象锁，修改条件，通知在对象上等待的线程

    管道输入输出流：用于线程之间的数据传输，媒介为内存。输入输出之间要进行connect。

    join():等待线程终止，使所属线程A正常执行，使其前驱线程（当前线程）进入等待状态，只有到线程A终止后，前驱线程才可以
    从join()方法中返回。主线程创建并启动子线程，内部采用wait()方法实现，会释放锁

    ThreadLocal:线程变量，解决变量在不同线程之间的隔离性，不同的线程具有自己的值。Threadlocal里面有一个内部类
    ThreadloalMap,存放entry类型的数组，entry类型的键为Threadlocal类型，值任意。每个线程都有自己的threadlaocalmaop
    属性，保存自己的值。常用方法set():获取当前线程的threadLoaclMaop,在map里添加键值对，键为threadlocal,
    get()，获取当前线程的threadlocalMap,在maop里查看是否有键为threadLocal的键值对，获取值

    InheritableThreaLocal:子线程可以从父线程中获取值，若在子线程获取值时，父线程修改了值，子线程获取的为旧值